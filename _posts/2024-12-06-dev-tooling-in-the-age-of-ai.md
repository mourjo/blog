---
layout: post
title: Relevance of Developer Tooling in the Age of AI
date: 2024-12-06 07:22:50 +0100
category: musings
---
I have worked with unconventional languages all [throughout my career](https://mourjo.me/cv.pdf) - from Clojure and Elixir to bash and lately, Perl. Whether statically typed or not, the success of a language today *depends heavily on the developer tooling and developer experience*. 

Code is only just a means to an end — the end being value addition for the customer. Languages with extensive tooling make it easier for developers, thereby increasing their value proposition to the business. I find that the effectiveness of the median developer is dependent on a language's tooling support - finding usages of a method, renaming a method, stepping through a codepath just to see where something gets updated, and so on...

This is the kind of [accidental complexity](https://www.markhneedham.com/blog/2010/03/18/essential-and-accidental-complexity/) that today’s tech ecosystem is ossified by -- **missing language capabilities being solved with tooling has led to an over-reliance of developers on the tooling rather than the language itself**. Think about it — would you write Java without Lombok or boilerplate code generation?  

> 
> It’s hard to imagine a surer sign that one is dealing with an irrational economic system than the fact that the prospect of eliminating drudgery is considered to be a problem.
> 
> -- David Graeber, [Bullshit Jobs: A Theory](https://www.goodreads.com/book/show/38217638-bullshit-jobs)
>

With LLMs to assist developers writing code, I think *the value proposition of developer tooling will take a new shape*. There will always be a need for some sort of tooling, but it may turn out to be *general-purpose tools*, rather than *language-specific ones* that win.

In a world where the barrier to entry into coding is lower, the test of a language's success will depend solely (and rightly) on its ability to deliver business value. If a language is fundamentally more effective in doing so -- irrespective of its tooling -- it may come out on top in the age of AI. 

After years of working with Java (and relying heavily on the tooling ecosystem), I will now be betting on Clojure.

> It is just simpler, and easier, and less occluding to write expressive code in Clojure. It requires fewer lines. It requires fewer characters. It requires fewer hours. It requires fewer mental gymnastics. Lisp (Clojure) is functional. And the future is looking very functional to me.
>
> -- [Uncle Bob](https://blog.cleancoder.com/uncle-bob/2019/08/22/WhyClojure.html)

